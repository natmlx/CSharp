# C# Coding Conventions
This is a comprehensive document on our C# coding conventions at NatML. First, it is important to mention our guiding philosophies:

1. **Expressiveness**. It isn't just enough for code to work as expected; it should tell a story. Often in engineering, the *why* of a certain design is more important than the *what*, and this holds more true as organizational and code complexity scales. 

2. **Modularity**. Inspired by the excellent software design over at Apple, we strive to build perfectly modular API's. We want our API's to be like onions: start with incredibly easy, functional abstractions, but provide hooks for developers to peel as deep as they might need to for their specific use case.

3. **Performance**. Our API's power performance-critical flows in resource-constrained devices: machine learning, camera streaming, video recording, and more. As such, we write highly performance-concious code, leveraging important aspects of the C# language (thanks to the designers of the language for their stellar work).

This guide will start with higher-level design aspects, before getting more specific about syntactical conventions. Let's begin:

## Table of Contents
*INCOMPLETE*

## 1. Classes
*INCOMPLETE*

### 1.1: Copyright
*INCOMPLETE*

### 1.2: Namespaces
*INCOMPLETE*

### 1.3: `using` Statements
*INCOMPLETE*

### 1.4: XML Documentation
*INCOMPLETE*

### 1.5: Inheritance
*INCOMPLETE*

### 1.6: Explicit Resource Management and `IDisposable`
*INCOMPLETE*

### 1.7: Variables
*INCOMPLETE*

### 1.8: Properties
*INCOMPLETE*

### 1.9: Indexers
*INCOMPLETE*

### 1.10: Events
*INCOMPLETE*

### 1.11: Constructors
*INCOMPLETE*

### 1.12: Partial Classes
*INCOMPLETE*

### 1.13: Nested Classes
*INCOMPLETE*

## 2. Static Classes
*INCOMPLETE*

### 2.1: State
*INCOMPLETE*

## 3. Structs
*INCOMPLETE*

### 3.1 Considerations on `struct` vs `class`
*INCOMPLETE*

### 3.2 Pass by Reference
*INCOMPLETE*

### 3.3 Destructuring
*INCOMPLETE*

## 4. General Syntax
*INCOMPLETE*

## 5. Performance
*INCOMPLETE*